# 엔티티의 커스텀 필드가 자꾸 바뀐다면? EAV 모델 적용기

안녕하세요! 교회용 SaaS 서비스 [**‘스르스르’**](https://www.srsr.kr/)를 개발·운영하고 있는 아기 개발자입니다. 서비스 홍보도 할 겸, 개발하며 겪었던 여러 이슈를 블로그를 통해 나눠보려고 합니다. 

이번 글에서는 서비스 운영 중 겪은 문제 하나와, 이를 어떻게 기술적으로 해결했는지를 공유해보려고 합니다.

## 해주세요
어떤 서비스든 운영을 하다 보면 “사용자마다 다른 정보를 입력받도록 해주세요”, “필드를 하나만 더 추가 해주세요” 같은 요청을 자주 받게 됩니다. 제가 운영하고 있는 '모힘'도 마찬가지였습니다. 

// TODO: 사진 자료 추가하기

사실 필드 하나를 추가하는 일은 큰 문제가 아닐 수 있습니다. 매번 하던 것처럼 ORM 엔티티와 DB 엔티티에 필드 혹은 컬럼을 추가하고 대응하는 적절한 코드를 짜면 되는 일이니까요. 하지만 **요구사항을 수용해야 하는 대상이 하나가 아니라면 어떨까요?** 그리고 그 대상들이 **각자 서로 다른 속성을 원한다면?**

// TODO: 누구나 계획은 있다. 쳐맞기 전까지는

### 교회마다 다른 요구사항

문제는 단일 교회를 대상으로 운영하던 '모힘'을, 여러 교회가 사용할 수 있는 교회용 SaaS 서비스 ‘스르스르’로 개편할 때 발생했습니다.

- A 교회는 “세례 여부”를 입력 받고 싶어 하고,  
- B 교회는 “입교일”을 중요하게 생각하며, 
- C 교회는 위의 두 요소 모두 필요없다고 생각할 수 있죠.

그럼 어떻게 해야할까요? 가장 쉬운 방법은 늘 해왔던 대로 하는거죠.

// TODO: 사진 자료

쉽네요! 혹시나 해당 컬럼을 사용하지 않는 교회가 있다면 null 값을 넣어주면 해결입니다. 

그런데 말입니다. 한국에는 교회가 약 60000만개 이상 있는 것으로 추정됩니다. 교회별로 커스텀 속성 추가 요청을 하나씩만 수용해도 ChurchMember 엔티티의 컬럼수는 60000개가 됩니다. 또 일시적으로 요구사항이 들어온다는 보장도 없기에 극단적으로는 60000만 번 이상의 배포가 이루어져야 하겠죠. DDL 작업과 함께 말입니다.

운영기간이 늘어나면 날수록 특정 교회만 사용하는 필드가 점점 늘어나고 그에 따라 코드도 분기 처리가 많아지고, 배포도 빈번해지고 ~~가정이 무너지고 사회가 붕괴되고~~...

### 구조적 개선이 필요하다

스르스르 팀은 위와 같은 상황이 적절치 못하다고 생각했습니다. 또한 교회마다 다른 형태의 속성을 관리하고 싶다는 요구사항은 실제 사용자 입장에서 매우 중요한 가치라고 판단했습니다. 

그래서 저희는 **속성을 테이블의 컬럼으로 고정하지 않고, Key-Value 형태로 저장할 수 있다면 어떨까?** 라는 아이디어를 바탕으로 해결책을 구상했고, 최종적으로 **EAV(Entity-Attribute-Value) 모델**을 도입하기로 결정했습니다.

## EAV 모델이란?

// TODO: EAV 모델 사진

EAV 모델이란 Entity-Attribute-Value의 약자로 객체(Entity)의 속성(Attribute)과 해당하는 값(Value)를 일종의 Key-Value 형태로 표현할 수 있는 것이 특징입니다. 데이터베이스 엔티티로 표현할 수 있는 매우 기본적인 형태는 위와 같습니다.  

희소하거나 매우 동적인 데이터를 효율적으로 저장하기 위해 고안된 모델로, 적절한 예시로는 앞서 소개한 케이스가 매우 적절합니다. 

### 모델링 적용

// TODO: 사진자료

특정 교회에서는 필요하지만 다른 대부분의 교회에서 필요하지 않은 데이터는 null 값으로 표현이 됩니다. 이 경우, 컬럼을 추가하여 수평적으로 데이터베이스를 확장하게 되면 불필요하게 낭비되는 공간들이 점점 늘어날겁니다. 물론 성능에도 영향을 줄 수 있습니다. 

// TODO: 사진자료

이것을 교회별로 필요한 데이터만을 저장할 수 있도록 설계하면 어떨까요? 스르스르팀은 EAV 모델을 기반으로 위와 같은 설계를 적용해보았습니다. 

기존 EAV 모델의 형태에 서비스에서 필요한 추가적인 컬럼을 추가하여 단점을 보완했습니다. is_required 는 성도가 필수로 지녀야하는 데이터인지 결정하도록 하였으며, data_type은 속성 데이터의 타입을 결정하도록 하였습니다. 

## EAV는 만능이 아니다 

물론 EAV도 만능이 아닙니다. 당장 구글에 EAV 모델을 검색하면 가장 먼저 만날 수 있는 자료 중 하나가 EAV가 안티패턴이라는 내용입니다. 그럼 EAV는 왜 안티패턴이라고 불릴까요? 

* 강제 무결성 제약 조건의 부재. 예: DBMS가 참조 무결성을 강제하지 않거나 속성의 값이 허용 가능한 범위 내에 있는지 확인하지 않음
* 쿼리가 매우 비효율적입니다, 단일 레코드의 대응을 반환하기 위해 많은 자체 조인을 수행하게 됨
* 쿼리를 읽을 수 없음
* 설계가 자체 문서화되지 않음
* 속성을 즉석에서 추가할 수 있어 설계자가 설계가 매우 유연하다는 착각을 일으킴

EAV의 대표적인 단점으로 뽑히는 내용들입니다. 