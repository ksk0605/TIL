# S3 버킷 파티셔닝

단일 교회만 지원하던 백엔드 시스템을 개편하면서 변경해야하는 구조 중에 하나로 S3 버킷이 존재했다. 

성도의 주소록을 다루는 서비스이기 때문에 성도 프로필 사진은 매우 중요한 요소 중 하나이며 빠른 조회와 확장성 있는 구조를 만드는 것을 고려하는 것이 좋다는 판단을 했다. 

## S3는 폴더가 아니다

S3를 AWS에서 제공하는 클라우드 폴더 정도로 알고 있었던 터라 대중적으로 많이 택하는 구조가 있는지 궁금하여 조사 중 재미있는 개념을 발견했다. S3는 사실 디렉토리 시스템이 아닌 단순한 key-value 형태의 스토어라는 사실이다. 

```
aaa/
  L bbb/
    L ccc/
      L ddd.png
```
우리는 실제로 파일을 저장하게 되면 위와 같은 형태로 저장된다고 알고 있다. S3 콘솔에서 폴더 구조로 파일을 찾을 수 있도록 UI를 제공하기 때문이다. 

그러나 실제로는 

| key | value |
|-----|-------|
| aaa/bbb/ccc/ddd.png | {실제 파일 내용} |

와 같은 형태로 저장이 된다. 우리가 경로별 검색(ex. /aaa 내부 파일만 조회)가 가능한 이유는 AWS 내부적으로 prefix 를 기반으로 파일을 조회할 수 있도록 도와주기 때문이다. 

## prefix 기반 파티셔닝 

그러나 prefix 가 실제 파일을 조회하는데 아무런 영향을 끼치지 않는 것은 아니다. prefix는 실제 객체(S3에 저장되는 모든 파일들을 통칭) 조회 성능에 영향을 미친다. 왜냐하면 AWS가 내부적으로 prefix를 기반으로 파티셔닝을 진행하기 때문이다. 

파티셔닝이란 데이터를 특정한 단위로 저장소(ex. DB테이블)를 나누어 조회 성능을 올리는 기법이다. 예를 들어 1년짜리 결제 데이터 전체 중 특정 결제 데이터를 찾는 것 보다는 월별로 나누어진 테이블로부터 조회하는 것이 12배(러프하게 계산해보면) 빠를 수 있는 것이다. 

AWS에서는 prefix를 기준으로 파티셔닝을 진행하는데 이때 어떻게 파티셔닝 할 것인가는 서비스 특성에 따라 개발자가 고려하는 것이 필요하다. 

AWS 공식 문서에서는 접두사별로 초당 최소 3,500개의 PUT/COPY/POST/DELETE 또는 5,500개의 GET/HEAD 요청을 달성할 수 있다고 주장한다. 접두사를 10개를 만들면 55,000개의 읽기 요청을 감당할 수 있다는 것. 

## 서비스에 맞춰 생각해보기 

내가 속한 교회의 성도는 약 1000명이고 초당 트래픽이 많으면 300회 까지 발생한다. 우리는 ListView 에서 성도 프로필 이미지를 조회할 수 있고 페이지네이션을 적용했기 때문에 적게는 10 개에서 20개 정도의 데이터가 한번에 조회에서 발생한다. 최대 즉 많으면 최대 6000번 정도의 읽기 요청이 발생하게 되는 것. 이는 단일 파티셔닝된 S3 구조라면 성능에 영향을 줄 수 있는 트래픽이다. 

여러 교회를 지원하게 된 우리 서비스는 50명 이상의 교회 10000개 등록을 장기 목표로 두고 있다. 10000개 교회가 등록되었고 평균 성도가 100명이라고 한다면 100만명의 성도가 존재하는 상황을 가정할 수 있고, 객체는 100만개 모두 등록되어있다고 하자. 

이 경우 예상 트래픽은 최악의 경우 1,000,000명 × 20개로 초당 20,000,000개의 요청이 발생할 수 있다. 실제로는 이런 경우가 발생하기 어렵겠지만 성도 어플리케이션이라는 특성상 주일에 트래픽이 몰리는 상황은 충분히 발생할 수 있다. 

따라서 우리가 선택한 구조는 아래와 같다. 

```
s3
  ├── churches/
  │     ├── {churchId}/
  │     │     ├── churchMembers/
  │     │     │     ├── {churchMemberId}/
  │     │     │     │     ├── profile.jpg
  │     │     │     │     ├── profile_thumbnail.jpg
```

이 구조를 선택한 근거는 다음과 같다:

1. 교회 단위 파티셔닝
   - 각 교회별로 독립적인 prefix(churches/{churchId})를 가짐
   - 교회별 접근 패턴이 다르므로 자연스러운 트래픽 분산 효과
   - 10,000개 교회는 곧 10,000개의 파티션을 의미

2. 성능 최적화
   - 위 계산대로 최악의 경우 20,000,000 QPS 발생 가능
   - 10,000개의 파티션으로 나누면 파티션당 약 2,000 QPS
   - S3의 단일 prefix 처리량인 5,500 QPS보다 충분히 낮은 수치

3. 관리 용이성
   - 교회별 데이터 관리가 명확
   - 백업이나 삭제 작업 시 교회 단위로 쉽게 처리 가능

4. 확장성
   - 추후 교회별 다른 타입의 이미지(예: 교회 로고, 행사 사진 등) 추가 용이
   - 성도별 여러 이미지 저장 가능한 구조

5. 성능 최적화를 위한 추가 전략
   - profile_thumbnail.jpg로 미리보기 이미지 별도 관리
   - ListView에서는 thumbnail만 사용하여 트래픽과 로딩 시간 감소


# Reference
* [간단한 S3 파티셔닝으로 성능 최적화하기](https://ottl-seo.tistory.com/205)
* [Amazon S3의 “폴더”라는 환상을 파괴하고 그 실체를 알아보기](https://dev.classmethod.jp/articles/amazon-s3-folder-kr/)
* [모범 사례 설계 패턴: Amazon S3 성능 최적화](https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/optimizing-performance.html)
* [파티셔닝이란 무엇인가요?](https://docs.aws.amazon.com/ko_kr/athena/latest/ug/ctas-partitioning-and-bucketing-what-is-partitioning.html)
