# 12919번 python 문제 풀이 

> [백준 12919번 A와 B 2](https://www.acmicpc.net/problem/12919)

### 사고 흐름

> 첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 49, 2 ≤ T의 길이 ≤ 50, S의 길이 < T의 길이)

S의 길이는 1~49, T의 길이는 2~50. S의 길이 * T의 길이만큼 아무리 많이 반복한다고 하더라도 O(n^2) 풀이도 문제없음. 

제한시간도 2초(최대 2억번, 파이썬이니 보수적으로 6000만번 정도)이니 일단 완탐이 가능할 것으로 보임.

그럼 S로 B를 만들 수 있는 경로를 모두 찾는 것은 어떨까?

매회 S에 A를 추가 하는 행위, B를 추가하고 문자열을 뒤집는 행위를 반복하며 T의 길이가 될때까지 반복하고, 그 경우의 수 안에 T가 존재하는지 확인해보자.  -> BFS 방식으로!

어떤 자료구조로 저장할까. 반복의 결과로 글자 수 마다 특정한 문자열들이 존재할 것이다. 딕셔너리가 적절할 듯 하다. 

```python 
dict { 
    글자수 : [글자수와 동일한 연산 결과들, ...]
}
```

### 1번째 풀이

```python 
import sys

s = sys.stdin.readline().strip()
t = sys.stdin.readline().strip()

d = {}
d[len(s)] = [s]

for i in range(len(s) + 1, len(t)+1):
    d[i] = []
    for v in d[i-1]:
        d[i].append(v + 'A')
        d[i].append((v + 'B')[::-1])

if t in d[len(t)]:
    print(1)
else :
    print(0)
```

젠장 메모리 초과다. 뭐가 문제지?  

S가 한글자이고 B가 최대인 50글자일 경우에 딕셔너리는 글자수마다 2의 제곱으로 커진다. 

```
1 : 1개
2 : 2개 
3 : 4개 
...
50: 2의 49승개 -> 562,949,953,421,312
```
최악의 경우 50번째에서 562,949,953,421,312 개의 데이터를 저장해야한다. 1개부터 50개까지 전부 합하면 더 커질 것이다. 

생각해보자. 탐색 중 모든 데이터를 가지고 있을 필요가 있나? 데이터 중에는 정답에 근접하지도 못할 것들도 있다. 

예를들면, S가 'A'인데 정답이 T가 'AAA'이면 B를 더하고 뒤집는 연산결과들은 아예 필요가 없다. 

그럼 역으로 접근하는 것은 어떨까. **T로 부터 시작해서 A를 더하는 연산과 B를 더하고 뒤집는 연산이 가능한 단어인지부터 검증**해서 불가능하다면 애초에 저장 자체를 하지 않도록 해보자. 

### 2번째 풀이 

```python 
import sys

s = sys.stdin.readline().strip()
t = sys.stdin.readline().strip()

d = {}
d[len(t)] = [t]

for i in range(len(t) - 1, len(s) - 1, -1):
    # 바로 전 데이터가 비어있다면 애초에 아래 if문 두 연산이 발생하지도 않았다는 것. 즉, S가 T가 될 가능성이 아예 없음. 그니까 탈출
    if len(d[i+1]) == 0:
        break

    d[i] = []
    for v in d[i+1]:
        # A붙이는 연산이 가능하려면 끝에가 A로 끝나야 함
        if v[-1] == 'A':
            d[i].append(v[0:-1])
        # B붙이고 뒤집는 연산이 가능하려면 처음이 B로 시작해야함. 
        if v[0] == 'B':
            d[i].append(v[::-1][0:-1])


# break로 중간에 끊겼으면 실패
if len(s) not in d.keys():
    print(0)
# s가 들어있으면 성공 아님 실패
elif s in d[len(s)]:
    print(1)
else :
    print(0)
```

성공이다!